/*
题目描述
输入10个整数，将其中最小的数与第一个数对换，把最大的数与最后一个数对换。要求用3个函数实现，分别为输入10个数、进行处理、输出10个数。要求使用指针的方法进行处理。

输入
用空格隔开的10个整数。

输出
输出进行题目描述操作之后的10个整数，每个整数之后输出一个空格。
请注意行尾输出换行。

样例输入
1 5 2 4 9 0 3 8 7 6
样例输出
0 5 2 4 6 1 3 8 7 9 
*/
/*分析：
一开始不晓得如何挑出最大的，这个区别于冒泡排序；然后我借鉴了[选择排序]的精神：
++++++++++++++++++++++简单选择排序基础程序++++++++++++++++++++
void selectsort(){
	for(int i=0;i<n;i++){//进行n趟操作
		int k =0;
		for(int j=i;j<=n;j++){//选出i~n中最小元素，记录下标为k
			if(a[j]<a[k]){
				k=j;
			}
		}
		int temp=a[i];//交换a[k]与a[i]
		a[i]=a[k];
		a[k]=temp;
	}
}
+++++++++++++++++++++简单选择排序基础程序+完++++++++++++++++++
然后我就写了一个挑出最大值并且与数组最后一个元素交换的函数：
我因为指针不怎么熟练，着实纠结了一把交换地址后值会不会变，然后我想了一下指针的原理，在此我编了一个故事，加深对指针的记忆，可能有疏漏，欢迎补充：
有七个除了颜色其他都一模一样的正方体盒子(封闭式的，打开盒子都配备唯一一把钥匙)，按颜色是红橙黄绿青蓝紫放好，偷偷告诉你哦，每一个盒子里都有一个体重不一的肉球球。
(红橙黄绿青蓝紫：暗示了数组的标号从0到7；
钥匙：暗示了指针
肉球球：暗示了数组里面数值大小不一的数)
已知：我们需要找到最重的肉球球，并且把它放到最后一个盒子里去；而最后一个盒子里的肉球球要放到最重肉球球原来的盒子里去。
解决：我们需要一位喜欢吃肉球球的好吃鬼按照盒子的颜色顺序来搬起这个盒子(共一趟就行)，每搬起一个盒子，好吃鬼总会想想这个肉球球和前面的肉球球，哪个更重。如果不如前面的重，就忘记这个肉球球；如果比前面的重，那么好吃鬼就会把这个肉球球所呆盒子的颜色记在心上。然后一直比较到紫盒子，这时好吃鬼已经确信，哪个颜色盒子里的肉球球更重了。
于是重头戏就来了！！！好吃鬼有两种选择，一种是换盒不换肉球球，一种是换肉球球不换盒。我这里用的是换肉球球不换盒
void change(){
	int flag=0;//记录目前最重肉球球所呆的盒子颜色
	int k=0;//记录数组的盒子号，0,1,2,3, ...
	int *tail,temp;
	tail=&a[9];
	for(int *p=a;p<a+10;p++){
		if(*p>a[flag]){//如果当前盒子里的肉球球比之前的大
			flag=k;//记录一下这个盒子颜色
		}
		k++;
	}
	temp=a[flag];//换肉球球不换盒子
	a[flag]=*tail;
	*tail=temp;
}


*/

#include<stdio.h>
int a[10];
void PushInt(){
	for(int *p=a;p<a+10;p++){
		scanf("%d",p);
	}
}
void PopInt(){
	for(int *p=a;p<a+10;p++){
		printf("%d ",*p);
	}
}
void change(){
	int flag1=0;
	int flag2=0;
	int k=0;
	int j=0;
	int *tail,*head,temp;
	tail=&a[9];
	head=&a[0];
	for(int *p=a;p<a+10;p++){
		if(*p>a[flag1]){
			flag1=k;
		}
		if(*p<a[flag2]){
			flag2=k;
		}
		k++;
	}
	
	temp=a[flag1];
	a[flag1]=*tail;
	*tail=temp;
	temp=a[flag2];
	a[flag2]=*head;
	*head=temp;

	
}
int main(){
	PushInt();
	change();
	PopInt();
	return 0;
}










